/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.0 scene.gltf --transform 
Files: scene.gltf [70.48KB] > /Users/matthewdavis/Downloads/venue_stage_for_great_events/scene-transformed.glb [2.36MB] (-3254%)
Author: QuarizonStudio (https://sketchfab.com/QuarizonStudio)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/venue-stage-for-great-events-d74b3baa5a74430fb3717cfa3d883476
Title: venue stage for great events
*/

import React from "react";
import { useCubeCamera, useGLTF } from "@react-three/drei";
import { useWindowStore } from "@spatialjs/core";
import * as THREE from "three";
import { useCallback } from "react";
import { useEffect } from "react";

export function Stage(props: any) {
  const { nodes, materials } = useGLTF("/stage-transformed.glb");

  const {
    setPosition: setWindowPosition,
    setRotation: setWindowRotation,
    selectedWindow,
  } = useWindowStore();

  const handleClick = useCallback(
    (event: any) => {
      event.stopPropagation();
      // Calculate surface normal at the click point
      const face = event.face;
      const normal = face.normal.clone();
      normal.transformDirection(event.object.matrixWorld);
      console.log(event.point);
      // Calculate a point slightly in front of the clicked point along the surface normal
      const offsetDistance = 0.1; // Adjust this value as needed
      const offsetPoint = event.point
        .clone()
        .add(normal.multiplyScalar(offsetDistance));

      // Calculate rotation to face outward from the surface
      const rotationMatrix = new THREE.Matrix4().lookAt(
        normal,
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, 1, 0)
      );
      const rotation = new THREE.Euler().setFromRotationMatrix(rotationMatrix);

      if (selectedWindow) {
        setWindowPosition(selectedWindow, offsetPoint);
        setWindowRotation(selectedWindow, rotation);
        useWindowStore.getState().updateWindow(selectedWindow, {
          disableTiling: true,
          position: offsetPoint,
          rotation: rotation,

          followCamera: false,
        });
      }
    },
    [setWindowPosition, setWindowRotation, selectedWindow]
  );
  return (
    <group {...props} dispose={null}>
      <mesh
        geometry={nodes.house_house_0.geometry}
        material={materials.house}
        position={[0, 5.358, 0]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[36.996, 23.744, 5.364]}
      />
      <mesh
        geometry={nodes.wall_wall1_0.geometry}
        material={materials.wall1}
        rotation={[-Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes.wall_wall2_0.geometry}
        material={materials.wall2}
        rotation={[-Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes.stage_stage3_0.geometry}
        material={materials.stage3}
        position={[0, 0.408, -3.23]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[20.878, 7.132, 0.412]}
      />
      <mesh
        geometry={nodes.stage_stage1_0.geometry}
        material={materials.stage1}
        position={[0, 0.408, -3.23]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[20.878, 7.132, 0.412]}
      />
      <mesh
        geometry={nodes.stage_stage2_0.geometry}
        material={materials.stage2}
        position={[0, 0.408, -3.23]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[20.878, 7.132, 0.412]}
      />
      <mesh
        geometry={nodes.backwall_backwall4_0.geometry}
        material={materials.backwall4}
        position={[0, 0.783, 0]}
        rotation={[-Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes.backwall_backwall1_0.geometry}
        material={materials.backwall1}
        position={[0, 0.783, 0]}
        rotation={[-Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes.backwall_backwall5_0.geometry}
        material={materials.backwall5}
        position={[0, 0.783, 0]}
        rotation={[-Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes.backwall_backwall2_0.geometry}
        material={materials.backwall2}
        position={[0, 0.783, 0]}
        rotation={[-Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes.backwall_backwall6_0.geometry}
        material={materials.backwall6}
        position={[0, 0.783, 0]}
        rotation={[-Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes.screen1_screen1_0.geometry}
        material={materials.screen1}
        position={[0, 1.224, -10.741]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[12.786, 0.251, 0.412]}
        onClick={handleClick}
        pointerEventsType={{ deny: ["grab", "touch"] }}
      />
      <mesh
        geometry={nodes.light_light1_0.geometry}
        material={materials.light1}
        position={[-17.16, 8.394, -2.301]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[1, 1, 0.157]}
      />
      <mesh
        geometry={nodes.light_light2_0.geometry}
        material={materials.light2}
        position={[-17.16, 8.394, -2.301]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[1, 1, 0.157]}
      />
      <mesh
        geometry={nodes.dec_dec1_0.geometry}
        material={materials.dec1}
        rotation={[-Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes.dec_dec2_0.geometry}
        material={materials.dec2}
        rotation={[-Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes.spot2_spot2a_0.geometry}
        material={materials.spot2a}
        position={[0.231, -1.006, 29.534]}
        rotation={[-Math.PI / 2, 0, -Math.PI / 2]}
      />
      <mesh
        geometry={nodes.spot2_spot2b_0.geometry}
        material={materials.spot2b}
        position={[0.231, -1.006, 29.534]}
        rotation={[-Math.PI / 2, 0, -Math.PI / 2]}
      />
      <mesh
        geometry={nodes.seat_seat_0.geometry}
        material={materials.seat}
        position={[-1.397, 0.225, 9.162]}
        rotation={[-Math.PI / 2, 0, 0]}
      />
      <mesh
        geometry={nodes.screen2_screen2_0.geometry}
        material={materials.screen2}
        position={[21.277, 2.699, -4.981]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={[0.525, 0.525, 0.398]}
      />
      <mesh
        geometry={nodes.plant_plant_0.geometry}
        material={materials.plant}
        position={[9.64, 0.757, -9.883]}
        rotation={[Math.PI, 0.626, -Math.PI]}
        scale={[0.609, 0.623, 0.596]}
      />
      <mesh
        geometry={nodes.silver_frame_silver_frame_0.geometry}
        material={materials.silver_frame}
        position={[0, -0.328, -3.447]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={0.751}
      />
      <mesh
        geometry={nodes.spot1_spot1a_0.geometry}
        material={materials.spot1a}
        position={[0, -0.328, -3.447]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={0.751}
      />
      <mesh
        geometry={nodes.spot1_spot1b_0.geometry}
        material={materials.spot1b}
        position={[0, -0.328, -3.447]}
        rotation={[-Math.PI / 2, 0, 0]}
        scale={0.751}
      />
    </group>
  );
}

useGLTF.preload("/stage-transformed.glb");
